<html>
<head>
    <title>3D Tower Defense</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
        #tower {
            text-align: center;
            padding: 10px;
            z-index: 10;
            width: 100%;
            position: absolute;
        }
    </style>
</head>
<body>
    <div id="menu">
        <button type="button" id="addTowerButton">Add Tower</button>
        <button type="button" id="addBallButton">Add Ball</button>
    </div>
    <script type="text/javascript" src="libs/three.min.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <script type="text/javascript" src="libs/tween.min.js"></script>
    <script type="text/javascript" src="libs/physi.js"></script>
    <script type="text/javascript" src="js/tower.js"></script>
    <script type="text/javascript" src="js/enemy.js"></script>
    <script type="text/javascript">

        Physijs.scripts.worker = 'libs/physijs_worker.js';
        Physijs.scripts.ammo = '../ammo_lib/ammo.js';

        var camera, renderer, scene;
        var plane;
        var controls;
        var stats;
        var light;
        var hemiLight;
        var clock = new THREE.Clock();
        var addTowerBoolean = false;
        var towers = [];
        var enemies = [];
        var img;
        var uniforms

        init();
        animate();

        document.getElementById("addTowerButton").onclick = function() {addTowerBoolean = true;}
        document.getElementById("addBallButton").onclick = function() {
            var enemy = new Enemy()
            enemies.push(enemy);
            scene.add(enemy.ball)
            //enemy.initEnemyTween(enemy.ball)
        };
        document.addEventListener("mousedown", onDocumentMouseDown);

        function init() {
            //Kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            //camera.position.x = 50;
            camera.position.z = 50;
            //camera.position.y = -50;
            //camera.rotation.x=-0.5*Math.PI;

            //Controls
            controls = new THREE.TrackballControls(camera);
            controls.target.z = 10;
            controls.rotateSpeed = 1.0;
            controls.addEventListener('change', render);

            //Svet
            scene = new Physijs.Scene();
            scene.setGravity(new THREE.Vector3(0,0,-5));


            /*var planeGeo = new THREE.PlaneGeometry(100, 100, 1, 1);
            var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
            plane = new Physijs.PlaneMesh(planeGeo, planeMaterial);
            //plane.name = "plane";
            //plane1.receiveShadow = true;
            scene.add(plane)
            var axes = new THREE.AxisHelper(20);
            scene.add(axes)*/

            img = new Image();
            img.onload = addPlane;
            img.src = "assets/plane201.png"
            //addTerrain();
            //addPlane();

            /*var loader = new THREE.JSONLoader();
            loader.load("assets/kupola.json", function(geometry) {
                var material = new THREE.MeshBasicMaterial();
                var mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh)
            });*/


            //Luci
            light = new THREE.DirectionalLight( 0xffffff );
            light.position.set( 100, 100, 100);
            light.castShadow = true;
            light.shadowMapWidth = 2048;
            light.shadowMapHeight = 2048;
            //light.target = plane;
            scene.add( light );
            hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
            hemiLight.color.setHSL( 0.6, 1, 0.6 );
            hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
            hemiLight.position.set( 0, 500, 0 );
            hemiLight.shadowMapWidth = 2048;
            hemiLight.shadowMapHeight = 2048;
            scene.add( hemiLight );

            var ambientLight = new THREE.AmbientLight( 0xffffff );
            ambientLight.shadowMapWidth = 2048;
            ambientLight.shadowMapHeight = 2048;
            scene.add( ambientLight );

            camera.lookAt(scene.position);

            //Renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xeeeeee, 1.0);
            renderer.shadowMapType = THREE.PCFSoftShadowMap;
            renderer.shadowMapEnabled = true;
            document.body.appendChild(renderer.domElement);
            render();

        }

        function getHeightData(img,scale) {

            if (scale == undefined) scale=1;

            var canvas = document.createElement( 'canvas' );
            canvas.width = img.width;
            canvas.height = img.height;

            var context = canvas.getContext( '2d' );

            var size = img.width * img.height;
            var data = new Float32Array( size );

            context.drawImage(img,0,0);

            for ( var i = 0; i < size; i ++ ) {
                data[i] = 0
            }

            var imgd = context.getImageData(0, 0, img.width, img.height);
            var pix = imgd.data;

            var j=0;
            for (var i = 0; i<pix.length; i +=4) {
                var all = 0.299 * pix[i] + 0.587 * pix[i+1]+ 0.114 * pix[i+2];
                data[j++] = all/(12*scale);
            }

            return data;
        }

        function addPlane() {
            //get height data from img
            var data = getHeightData(img,0.5);

            // plane
            var geometry = new THREE.PlaneGeometry(500,500,200,200);
            var texture = new THREE.ImageUtils.loadTexture("assets/trava.png");
            var material = new THREE.MeshLambertMaterial( { map: texture, wireframe: false } );
            material.wrapAround = true;
            material.map.repeat.set(20, 20);
            material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
            //plane = new Physijs.PlaneMesh( geometry, material );

            //set height of vertices
            for ( var i = 0; i<geometry.vertices.length; i++ ) {
                geometry.vertices[i].z = data[i];
            }
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            plane = new Physijs.HeightfieldMesh( geometry, material, 0, 200 ,200);
            plane.castShadow = true;
            plane.receiveShadow = true;
            plane.receiveShadow = true;
            scene.add(plane);
            render();
        }

        function addTerrain() {
            var terrainTexture = new THREE.ImageUtils.loadTexture("assets/surface_test.png");
            var grassTexture = new THREE.ImageUtils.loadTexture("assets/trava.png");

            var shader = THREE.ShaderLib[ "normalmap" ];
            uniforms = THREE.UniformsUtils.clone( shader.uniforms );

            uniforms[ "enableDisplacement" ].value = true;
            uniforms[ "enableDiffuse" ].value = true;
            uniforms[ "tDisplacement" ].value = terrainTexture;
            uniforms[ "tDiffuse" ].value = grassTexture;
            uniforms["wrapRGB"].value= new THREE.Vector3(10,10,10);
            uniforms[ "uDisplacementScale" ].value = 43;
            uniforms[ "uRepeat" ].value = new THREE.Vector2(2,2);
            //uniforms["tDiffuse"].value.repeat = new THREE.Vector2(2,2)


            var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, wireframe: false };
            var planeMaterial = new THREE.ShaderMaterial( parameters );
            //planeMaterial.map = grassTexture;

            var planeGeo = new THREE.PlaneGeometry(500, 500, 400, 400);
            planeGeo.computeTangents(); /**/
            planeGeo.computeFaceNormals();
            planeGeo.computeVertexNormals();

            //var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff}); /**/

            var terrain = new THREE.Mesh(planeGeo, planeMaterial);
            terrain.name = "terrain";
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            scene.add(terrain);
        }

        //iniclizacija animacije zoge
        function initBallTween(ball) {
            var current = {x: 0};
            var update = function () {
                ball.__dirtyPosition = true;
                ball.position.x = current.x;
            }

            var tweenHead = new TWEEN.Tween(current).to({x: 20}, 5000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(update);

            var tweenBack = new TWEEN.Tween(current).to({x: -20}, 5000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(update);

            tweenBack.chain(tweenHead);
            tweenHead.chain(tweenBack);
            tweenHead.start();
        }


        var projector = new THREE.Projector();
        function onDocumentMouseDown(event) {
            event.preventDefault();
            var vector = new THREE.Vector3(
                    (event.clientX / window.innerWidth ) * 2 - 1,
                    -( event.clientY / window.innerHeight ) * 2 + 1,
                    0.5);
            projector.unprojectVector(vector, camera);
            var raycaster = new THREE.Raycaster(camera.position,
                    vector.sub(camera.position).normalize());
            var intersects = raycaster.intersectObjects([plane]);
            if (intersects.length > 0) {
                if(addTowerBoolean == true) {
                    var tower = new Tower(intersects[0].point);
                    towers.push(tower);
                    tower.animateTower();
                    addTowerBoolean = false;
                }
            }
        }

        /*function animateTowers() {
            towers.forEach(function(e) {
                if (e.enemiesIner.length == 0) {
                    return;
                }
                var i;
                for(i in e.enemiesIner) {
                    //console.log(e.enemiesIner[i]);
                    var dist = e.range.position.distanceTo(e.enemiesIner[i].position);
                    var tRange = e.range.geometry.parameters.radius;
                    if(dist > tRange + 1) {
                        e.enemiesIner.shift();
                    }
                }
                if (e.enemiesIner.length != 0) {
                    e.range.getObjectByName("towerGroup").getObjectByName("top").lookAt(e.enemiesIner[0].position);
                }
                //console.log("IN RANGE");
            });
        }*/



        function animate() {
            render();
            var delta = clock.getDelta();
            controls.update(delta);
            TWEEN.update();
            scene.simulate();
            requestAnimationFrame( animate );
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>